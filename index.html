<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Embedding Inversion via Conditional Masked Diffusion</title>
<style>
*,*::before,*::after{margin:0;padding:0;box-sizing:border-box}
:root{
  --bg:#fafafa;--surface:#fff;--border:#d8d8d8;
  --text:#1a1a2e;--dim:#666;--accent:#e17055;
  --green:#00b894;--mask:#c0c0c0;
  --mono:"Berkeley Mono","JetBrains Mono","Fira Code",monospace;
  --radius:4px;
}
html{font-size:15px}
body{font-family:var(--mono);background:var(--bg);color:var(--text);min-height:100vh;line-height:1.5}
::selection{background:var(--accent);color:#fff}

.wrap{max-width:760px;margin:0 auto;padding:2.5rem 1.5rem 3rem}

header{text-align:center;margin-bottom:2.5rem}
h1{font-size:1.6rem;font-weight:600;letter-spacing:-0.01em;color:var(--text)}
.sub{color:var(--dim);font-size:.8rem;margin-top:.4rem}
.sub a{color:var(--dim);text-decoration:underline;transition:color .2s}
.sub a:hover{color:var(--accent)}

/* Fieldsets - TurboPuffer style */
fieldset{
  background:var(--surface);
  border:2px dashed var(--border);
  border-radius:var(--radius);
  padding:1.5rem;
  margin-bottom:1.5rem;
}
legend{
  font-size:.65rem;
  text-transform:uppercase;
  letter-spacing:.12em;
  color:var(--dim);
  font-weight:600;
  padding:0 .5rem;
}

/* Model selector - tabs style */
.model-selector{
  display:inline-flex;gap:0;margin-bottom:1.2rem;
  border:1.5px solid var(--border);border-radius:var(--radius);
  overflow:hidden;
}
.model-btn{
  padding:.5rem 1.2rem;
  background:transparent;color:var(--text);
  border:none;border-right:1.5px solid var(--border);
  font-family:var(--mono);font-size:.75rem;font-weight:600;
  cursor:pointer;transition:all .2s;text-align:center;
  letter-spacing:.02em;
}
.model-btn:last-child{border-right:none}
.model-btn:hover{background:#f5f5f5}
.model-btn.active{
  background:var(--accent);color:#fff;
}

/* input area */
.input-row{position:relative;display:flex;align-items:center}
.input-row input{
  width:100%;padding:.65rem 2.5rem .65rem .8rem;
  border:1.5px solid var(--border);border-radius:var(--radius);
  font-family:var(--mono);font-size:.85rem;
  background:var(--surface);color:var(--text);outline:none;
  transition:border-color .2s;
}
.input-row input:focus{border-color:var(--accent)}
.input-row input::placeholder{color:#aaa;font-style:italic}
.dice{
  position:absolute;right:8px;top:50%;transform:translateY(-50%);
  background:none;border:none;cursor:pointer;font-size:1.1rem;
  opacity:.4;transition:opacity .15s;
}
.dice:hover{opacity:.8}

/* buttons - outlined style */
.btn{
  display:inline-block;padding:.55rem 1.4rem;
  background:transparent;color:var(--accent);
  border:1.5px solid var(--accent);border-radius:var(--radius);
  font-family:var(--mono);font-size:.8rem;font-weight:600;
  cursor:pointer;transition:all .15s;margin-top:.8rem;
  letter-spacing:.02em;
}
.btn:hover{background:var(--accent);color:#fff}
.btn:disabled{opacity:.3;cursor:not-allowed}
.btn.btn-primary{
  background:var(--accent);color:#fff;
}
.btn.btn-primary:hover{background:#4a4ab0}

/* embedding viz */
#embed-result{display:none}
.stats-row{
  display:flex;gap:1.5rem;font-size:.75rem;
  color:var(--dim);margin-bottom:.8rem;flex-wrap:wrap;
}
.stats-row span{white-space:nowrap}
.stats-row .val{color:var(--text);font-weight:600;margin-left:.3rem}

canvas#histogram{width:100%;height:110px;border-radius:var(--radius);background:var(--surface);border:1.5px solid var(--border)}

/* invert section */
#invert-section{display:none}
#invert-result{display:none}

/* token grid */
.token-grid{
  display:flex;flex-wrap:wrap;gap:5px;
  font-size:.8rem;
  margin-top:.8rem;
}
.token{
  padding:3px 7px;border-radius:3px;
  transition:all .25s ease;
  border:1px solid transparent;
}
.token.masked{background:#f0f0f0;color:var(--mask);border-color:var(--border)}
.token.revealed{background:var(--surface);color:var(--text);font-weight:600;border-color:var(--border)}
.token.just-changed{
  background:#fde8e2;color:var(--accent);font-weight:700;
  border-color:var(--accent);
  animation:pop .3s ease;
}
@keyframes pop{0%{transform:scale(1.12)}100%{transform:scale(1)}}

/* comparison */
.compare{margin-top:1.2rem;font-size:.8rem}
.compare-row{display:flex;gap:.6rem;margin-bottom:.5rem;align-items:baseline}
.compare-label{font-size:.65rem;text-transform:uppercase;letter-spacing:.1em;color:var(--dim);width:85px;flex-shrink:0;font-weight:600}
.compare-text{color:var(--text)}

.metric{
  display:inline-flex;align-items:center;gap:.4rem;
  font-size:.75rem;color:var(--dim);
  margin-top:.6rem;
}
.metric .val{color:var(--green);font-weight:700;font-size:.9rem}

.step-info{font-size:.7rem;color:var(--dim);margin-top:.6rem}

/* progress */
.progress-bar{height:2px;background:#e5e5e5;border-radius:1px;margin-top:.6rem;overflow:hidden}
.progress-fill{height:100%;background:var(--accent);border-radius:1px;transition:width .15s;width:0%}

footer{text-align:center;margin-top:2.5rem;font-size:.7rem;color:var(--dim);border-top:1px solid var(--border);padding-top:1.5rem}
footer a{color:var(--dim);text-decoration:underline}
footer a:hover{color:var(--accent)}
</style>
</head>
<body>
<div class="wrap">

<header>
  <h1>Embedding Inversion via Conditional Masked Diffusion</h1>
  
  <div class="sub" style="margin-top:0.3rem">
    <a href="https://github.com/hanxiao/embedding-inversion-demo" target="_blank">github.com/hanxiao/embedding-inversion-demo</a>
  </div>
</header>

<!-- Step 1: Input & Embed -->
<fieldset>
  <legend>Input</legend>
  
  <!-- Model selector -->
  <div class="model-selector">
    <button class="model-btn active" onclick="selectModel('qwen3')">Qwen3-Embedding</button>
    <button class="model-btn" onclick="selectModel('gemma')">EmbeddingGemma</button>
  </div>
  
  <div class="input-row">
    <input type="text" id="input-text" placeholder="Enter a sentence..." />
    <button class="dice" onclick="randomSentence()" title="Random sentence">&#x1F3B2;</button>
  </div>
  <button class="btn btn-primary" id="btn-embed" onclick="doEmbed()">Embed</button>
</fieldset>

<!-- Embedding Result -->
<fieldset id="embed-result">
  <legend>Embedding</legend>
  <div class="stats-row">
    <span>dim <span class="val" id="stat-dim">-</span></span>
    <span>min <span class="val" id="stat-min">-</span></span>
    <span>max <span class="val" id="stat-max">-</span></span>
    <span>norm <span class="val" id="stat-norm">-</span></span>
    <span>entropy <span class="val" id="stat-entropy">-</span></span>
  </div>
  <canvas id="histogram"></canvas>
</fieldset>

<!-- Step 2: Invert -->
<div id="invert-section">
  <fieldset>
    <legend>Diffusion Decoding</legend>
    <button class="btn" id="btn-invert" onclick="doInvert()">Invert</button>
    <div class="progress-bar" id="progress-bar"><div class="progress-fill" id="progress-fill"></div></div>
    <div class="step-info" id="step-info"></div>

    <div id="invert-result">
      <div class="token-grid" id="token-grid"></div>

      <div class="compare">
        <div class="compare-row">
          <span class="compare-label">Original</span>
          <span class="compare-text" id="original-text"></span>
        </div>
        <div class="compare-row">
          <span class="compare-label">Recovered</span>
          <span class="compare-text" id="recovered-text"></span>
        </div>
      </div>

      <div class="metric">
        cosine similarity <span class="val" id="cosine-sim">-</span>
      </div>
    </div>
  </fieldset>
</div>

<footer>
  Â© 2025 Han Xiao
</footer>

</div>

<script>
let currentEmbedding = null;
let currentText = '';
let selectedModel = 'qwen3';

const MODEL_NAMES = {
  'qwen3': 'Qwen3-Embedding',
  'gemma': 'EmbeddingGemma'
};

function selectModel(model) {
  selectedModel = model;
  
  // Update button states
  document.querySelectorAll('.model-btn').forEach(btn => {
    btn.classList.remove('active');
  });
  event.target.classList.add('active');
  
  // Update subtitle
  document.getElementById('header-sub').textContent = MODEL_NAMES[model] + ' | Conditional Masked Diffusion';
  
  // Reset state if user switches models
  currentEmbedding = null;
  document.getElementById('embed-result').style.display = 'none';
  document.getElementById('invert-section').style.display = 'none';
}

async function randomSentence() {
  const r = await fetch('/random');
  const d = await r.json();
  document.getElementById('input-text').value = d.text;
}

async function doEmbed() {
  const text = document.getElementById('input-text').value.trim();
  if (!text) return;
  currentText = text;

  const btn = document.getElementById('btn-embed');
  btn.disabled = true;
  btn.textContent = 'Encoding...';

  try {
    const r = await fetch('/encode', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({text, model: selectedModel})
    });
    const d = await r.json();
    currentEmbedding = d.embedding;

    // Stats
    const arr = d.embedding;
    const min = Math.min(...arr);
    const max = Math.max(...arr);
    const norm = Math.sqrt(arr.reduce((s,v) => s + v*v, 0));
    document.getElementById('stat-dim').textContent = arr.length;
    document.getElementById('stat-min').textContent = min.toFixed(3);
    document.getElementById('stat-max').textContent = max.toFixed(3);
    document.getElementById('stat-norm').textContent = norm.toFixed(2);
    // Shannon entropy of embedding distribution
    const nbins = 50;
    const emin = Math.min(...arr); const emax = Math.max(...arr);
    const bw = (emax - emin) / nbins || 1;
    const bins = new Array(nbins).fill(0);
    arr.forEach(v => { const b = Math.min(nbins-1, Math.floor((v - emin) / bw)); bins[b]++; });
    const n = arr.length;
    const entropy = -bins.filter(b=>b>0).reduce((s,b) => s + (b/n)*Math.log2(b/n), 0);
    document.getElementById('stat-entropy').textContent = entropy.toFixed(2);

    document.getElementById('embed-result').style.display = 'block';

    // Histogram (draw after element is visible so getBoundingClientRect works)
    requestAnimationFrame(() => drawHistogram(arr));
    document.getElementById('invert-section').style.display = 'block';

    // Reset invert state
    document.getElementById('invert-result').style.display = 'none';
    document.getElementById('progress-fill').style.width = '0%';
    document.getElementById('step-info').textContent = '';
    document.getElementById('btn-invert').disabled = false;
  } catch(e) {
    console.error(e);
  } finally {
    btn.disabled = false;
    btn.textContent = 'Embed';
  }
}

function drawHistogram(arr) {
  const canvas = document.getElementById('histogram');
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);
  const W = rect.width, H = rect.height;

  ctx.clearRect(0, 0, W, H);

  const nBins = 50;
  const min = Math.min(...arr), max = Math.max(...arr);
  const range = max - min || 1;
  const bins = new Array(nBins).fill(0);
  for (const v of arr) {
    const i = Math.min(Math.floor((v - min) / range * nBins), nBins - 1);
    bins[i]++;
  }
  const maxBin = Math.max(...bins);

  const pad = {l:0, r:0, t:8, b:0};
  const pw = (W - pad.l - pad.r) / nBins;

  for (let i = 0; i < nBins; i++) {
    const h = (bins[i] / maxBin) * (H - pad.t - pad.b);
    const x = pad.l + i * pw;
    const y = H - pad.b - h;

    const t = i / nBins;
    const r2 = Math.round(225 + t * 20);
    const g = Math.round(100 + t * 30);
    const b = Math.round(65 + t * 20);
    ctx.fillStyle = `rgb(${r2},${g},${b})`;
    ctx.fillRect(x, y, pw - 1, h);
  }
}

async function doInvert() {
  if (!currentEmbedding) return;

  const btn = document.getElementById('btn-invert');
  btn.disabled = true;
  btn.textContent = 'Inverting...';
  document.getElementById('invert-result').style.display = 'block';
  document.getElementById('original-text').textContent = currentText;
  document.getElementById('cosine-sim').textContent = '-';

  const grid = document.getElementById('token-grid');
  grid.innerHTML = '';

  let prevTokens = [];

  try {
    const r = await fetch('/decode', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({embedding: currentEmbedding, steps: 32, model: selectedModel})
    });

    const reader = r.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';
    let totalSteps = 32;
    let stepCount = 0;

    while (true) {
      const {done, value} = await reader.read();
      if (done) break;
      buffer += decoder.decode(value, {stream: true});

      const lines = buffer.split('\n');
      buffer = lines.pop();

      for (const line of lines) {
        if (!line.startsWith('data: ')) continue;
        const raw = line.slice(6).trim();
        if (raw === '[DONE]') continue;

        try {
          const d = JSON.parse(raw);
          stepCount++;

          if (d.total) totalSteps = d.total;
          if (d.total_steps) totalSteps = d.total_steps;
          const pct = d.progress ? d.progress * 100 : Math.min(100, (stepCount / totalSteps) * 100);
          document.getElementById('progress-fill').style.width = pct + '%';
          document.getElementById('step-info').textContent = `step ${d.step !== undefined ? d.step + 1 : stepCount}/${totalSteps}`;

          const tokens = d.tokens || [];
          grid.innerHTML = '';
          for (let i = 0; i < tokens.length; i++) {
            const span = document.createElement('span');
            // tokens can be objects {t: text, s: state} or strings
            const tok = typeof tokens[i] === 'object' ? tokens[i] : {t: tokens[i], s: 'u'};
            const text = tok.t || '';
            const isMask = text === '[MASK]' || text === '<mask>' || tok.s === 'm';
            const changed = tok.s === 'c' || (prevTokens[i] && prevTokens[i] !== text && !isMask);

            span.className = 'token ' + (isMask ? 'masked' : (changed ? 'just-changed' : 'revealed'));
            span.textContent = isMask ? '\u2588' : text;
            grid.appendChild(span);
          }
          prevTokens = tokens.map(t => typeof t === 'object' ? t.t : t);

          if (d.cosine_similarity !== undefined) {
            document.getElementById('cosine-sim').textContent = d.cosine_similarity.toFixed(4);
          } else if (d.cosine_sim !== undefined) {
            document.getElementById('cosine-sim').textContent = d.cosine_sim.toFixed(4);
          }
          if (d.text) {
            document.getElementById('recovered-text').textContent = d.text;
          }
        } catch(e) {}
      }
    }

    document.getElementById('progress-fill').style.width = '100%';
    document.getElementById('step-info').textContent = `done (${totalSteps} steps)`;
  } catch(e) {
    console.error(e);
  } finally {
    btn.disabled = false;
    btn.textContent = 'Invert';
  }
}

// Auto-load random on page load
window.addEventListener('load', randomSentence);
</script>
</body>
</html>
