<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Embedding Inversion</title>
<style>
*,*::before,*::after{margin:0;padding:0;box-sizing:border-box}
:root{
  --bg:#fff;--surface:#f9f9fb;--border:#e8e8ec;
  --text:#111;--dim:#888;--accent:#6c5ce7;--accent-light:#a29bfe;
  --green:#00b894;--mask:#d0d0d8;
  --mono:'SF Mono','Fira Code','JetBrains Mono','Cascadia Code',monospace;
  --sans:'Inter',-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;
  --radius:10px;
}
html{font-size:15px}
body{font-family:var(--sans);background:var(--bg);color:var(--text);min-height:100vh}
::selection{background:var(--accent);color:#fff}

.wrap{max-width:720px;margin:0 auto;padding:3rem 1.5rem 4rem}

header{text-align:center;margin-bottom:2.5rem}
h1{font-size:1.8rem;font-weight:700;letter-spacing:-0.02em;color:var(--text)}
.sub{color:var(--dim);font-size:.85rem;margin-top:.3rem;font-family:var(--mono)}

.card{background:var(--surface);border:1px solid var(--border);border-radius:var(--radius);padding:1.5rem;margin-bottom:1.25rem}
.card-label{font-size:.7rem;text-transform:uppercase;letter-spacing:.08em;color:var(--dim);margin-bottom:.75rem;font-weight:600}

/* Model selector */
.model-selector{
  display:flex;gap:8px;margin-bottom:1rem;
}
.model-btn{
  flex:1;padding:.5rem 1rem;
  background:#fff;color:var(--text);
  border:1.5px solid var(--border);border-radius:20px;
  font-family:var(--sans);font-size:.8rem;font-weight:600;
  cursor:pointer;transition:all .2s;text-align:center;
}
.model-btn:hover{border-color:var(--accent-light)}
.model-btn.active{
  background:var(--accent);color:#fff;
  border-color:var(--accent);
}

/* input area */
.input-row{position:relative;display:flex;align-items:center}
.input-row input{
  width:100%;padding:.7rem 2.8rem .7rem .9rem;
  border:1px solid var(--border);border-radius:8px;
  font-family:var(--mono);font-size:.9rem;
  background:#fff;color:var(--text);outline:none;
  transition:border-color .2s;
}
.input-row input:focus{border-color:var(--accent)}
.input-row input::placeholder{color:#bbb}
.dice{
  position:absolute;right:8px;top:50%;transform:translateY(-50%);
  background:none;border:none;cursor:pointer;font-size:1.2rem;
  opacity:.5;transition:opacity .15s;
}
.dice:hover{opacity:1}

/* buttons */
.btn{
  display:inline-block;padding:.6rem 1.6rem;
  background:var(--accent);color:#fff;border:none;border-radius:8px;
  font-family:var(--sans);font-size:.85rem;font-weight:600;
  cursor:pointer;transition:all .15s;margin-top:.75rem;
}
.btn:hover{background:#5b4bd5}
.btn:disabled{opacity:.4;cursor:not-allowed}
.btn-outline{
  background:transparent;color:var(--accent);
  border:1.5px solid var(--accent);
}
.btn-outline:hover{background:var(--accent);color:#fff}

/* embedding viz */
#embed-result{display:none}
.stats-row{
  display:flex;gap:1.5rem;font-family:var(--mono);font-size:.8rem;
  color:var(--dim);margin-bottom:.75rem;
}
.stats-row span{white-space:nowrap}
.stats-row .val{color:var(--text);font-weight:600}

canvas#histogram{width:100%;height:120px;border-radius:6px;background:#fff;border:1px solid var(--border)}

/* invert section */
#invert-section{display:none}
#invert-result{display:none}

/* token grid */
.token-grid{
  display:flex;flex-wrap:wrap;gap:6px;
  font-family:var(--mono);font-size:.85rem;
  margin-top:.75rem;
}
.token{
  padding:4px 8px;border-radius:5px;
  transition:all .25s ease;
  border:1px solid transparent;
}
.token.masked{background:var(--surface);color:var(--mask);border-color:var(--border)}
.token.revealed{background:#fff;color:var(--text);font-weight:600;border-color:var(--border)}
.token.just-changed{
  background:#f0edff;color:var(--accent);font-weight:700;
  border-color:var(--accent-light);
  animation:pop .3s ease;
}
@keyframes pop{0%{transform:scale(1.15)}100%{transform:scale(1)}}

/* comparison */
.compare{margin-top:1rem;font-size:.85rem}
.compare-row{display:flex;gap:.5rem;margin-bottom:.4rem;align-items:baseline}
.compare-label{font-size:.7rem;text-transform:uppercase;letter-spacing:.06em;color:var(--dim);width:90px;flex-shrink:0;font-weight:600}
.compare-text{font-family:var(--mono);color:var(--text)}

.metric{
  display:inline-flex;align-items:center;gap:.4rem;
  font-family:var(--mono);font-size:.8rem;color:var(--dim);
  margin-top:.5rem;
}
.metric .val{color:var(--green);font-weight:700;font-size:.95rem}

.step-info{font-family:var(--mono);font-size:.75rem;color:var(--dim);margin-top:.5rem}

/* progress */
.progress-bar{height:3px;background:var(--border);border-radius:2px;margin-top:.5rem;overflow:hidden}
.progress-fill{height:100%;background:var(--accent);border-radius:2px;transition:width .15s;width:0%}

footer{text-align:center;margin-top:2rem;font-size:.75rem;color:var(--dim)}
footer a{color:var(--accent);text-decoration:none}
</style>
</head>
<body>
<div class="wrap">

<header>
  <h1>Embedding Inversion</h1>
  <div class="sub" id="header-sub">Qwen3-Embedding | Conditional Masked Diffusion</div>
</header>

<!-- Step 1: Input & Embed -->
<div class="card">
  <div class="card-label">Input</div>
  
  <!-- Model selector -->
  <div class="model-selector">
    <button class="model-btn active" onclick="selectModel('qwen3')">Qwen3-Embedding</button>
    <button class="model-btn" onclick="selectModel('gemma')">EmbeddingGemma</button>
  </div>
  
  <div class="input-row">
    <input type="text" id="input-text" placeholder="Enter a sentence..." />
    <button class="dice" onclick="randomSentence()" title="Random sentence">&#x1F3B2;</button>
  </div>
  <button class="btn" id="btn-embed" onclick="doEmbed()">Embed</button>
</div>

<!-- Embedding Result -->
<div class="card" id="embed-result">
  <div class="card-label">Embedding</div>
  <div class="stats-row">
    <span>dim <span class="val" id="stat-dim">-</span></span>
    <span>min <span class="val" id="stat-min">-</span></span>
    <span>max <span class="val" id="stat-max">-</span></span>
    <span>norm <span class="val" id="stat-norm">-</span></span>
  </div>
  <canvas id="histogram"></canvas>
</div>

<!-- Step 2: Invert -->
<div id="invert-section">
  <div class="card">
    <div class="card-label">Diffusion Decoding</div>
    <button class="btn btn-outline" id="btn-invert" onclick="doInvert()">Invert</button>
    <div class="progress-bar" id="progress-bar"><div class="progress-fill" id="progress-fill"></div></div>
    <div class="step-info" id="step-info"></div>

    <div id="invert-result">
      <div class="token-grid" id="token-grid"></div>

      <div class="compare">
        <div class="compare-row">
          <span class="compare-label">Original</span>
          <span class="compare-text" id="original-text"></span>
        </div>
        <div class="compare-row">
          <span class="compare-label">Recovered</span>
          <span class="compare-text" id="recovered-text"></span>
        </div>
      </div>

      <div class="metric">
        cosine similarity <span class="val" id="cosine-sim">-</span>
      </div>
    </div>
  </div>
</div>

<footer>
  <a href="https://github.com/hanxiao/embedding-inversion-demo">github</a>
</footer>

</div>

<script>
let currentEmbedding = null;
let currentText = '';
let selectedModel = 'qwen3';

const MODEL_NAMES = {
  'qwen3': 'Qwen3-Embedding',
  'gemma': 'EmbeddingGemma'
};

function selectModel(model) {
  selectedModel = model;
  
  // Update button states
  document.querySelectorAll('.model-btn').forEach(btn => {
    btn.classList.remove('active');
  });
  event.target.classList.add('active');
  
  // Update subtitle
  document.getElementById('header-sub').textContent = MODEL_NAMES[model] + ' | Conditional Masked Diffusion';
  
  // Reset state if user switches models
  currentEmbedding = null;
  document.getElementById('embed-result').style.display = 'none';
  document.getElementById('invert-section').style.display = 'none';
}

async function randomSentence() {
  const r = await fetch('/random');
  const d = await r.json();
  document.getElementById('input-text').value = d.text;
}

async function doEmbed() {
  const text = document.getElementById('input-text').value.trim();
  if (!text) return;
  currentText = text;

  const btn = document.getElementById('btn-embed');
  btn.disabled = true;
  btn.textContent = 'Encoding...';

  try {
    const r = await fetch('/encode', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({text, model: selectedModel})
    });
    const d = await r.json();
    currentEmbedding = d.embedding;

    // Stats
    const arr = d.embedding;
    const min = Math.min(...arr);
    const max = Math.max(...arr);
    const norm = Math.sqrt(arr.reduce((s,v) => s + v*v, 0));
    document.getElementById('stat-dim').textContent = arr.length;
    document.getElementById('stat-min').textContent = min.toFixed(3);
    document.getElementById('stat-max').textContent = max.toFixed(3);
    document.getElementById('stat-norm').textContent = norm.toFixed(2);

    document.getElementById('embed-result').style.display = 'block';

    // Histogram (draw after element is visible so getBoundingClientRect works)
    requestAnimationFrame(() => drawHistogram(arr));
    document.getElementById('invert-section').style.display = 'block';

    // Reset invert state
    document.getElementById('invert-result').style.display = 'none';
    document.getElementById('progress-fill').style.width = '0%';
    document.getElementById('step-info').textContent = '';
    document.getElementById('btn-invert').disabled = false;
  } catch(e) {
    console.error(e);
  } finally {
    btn.disabled = false;
    btn.textContent = 'Embed';
  }
}

function drawHistogram(arr) {
  const canvas = document.getElementById('histogram');
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);
  const W = rect.width, H = rect.height;

  ctx.clearRect(0, 0, W, H);

  const nBins = 50;
  const min = Math.min(...arr), max = Math.max(...arr);
  const range = max - min || 1;
  const bins = new Array(nBins).fill(0);
  for (const v of arr) {
    const i = Math.min(Math.floor((v - min) / range * nBins), nBins - 1);
    bins[i]++;
  }
  const maxBin = Math.max(...bins);

  const pad = {l:0, r:0, t:8, b:0};
  const pw = (W - pad.l - pad.r) / nBins;

  for (let i = 0; i < nBins; i++) {
    const h = (bins[i] / maxBin) * (H - pad.t - pad.b);
    const x = pad.l + i * pw;
    const y = H - pad.b - h;

    const t = i / nBins;
    const r2 = Math.round(108 + t * 50);
    const g = Math.round(92 + t * 40);
    const b = Math.round(231 + t * 10);
    ctx.fillStyle = `rgb(${r2},${g},${b})`;
    ctx.fillRect(x, y, pw - 1, h);
  }
}

async function doInvert() {
  if (!currentEmbedding) return;

  const btn = document.getElementById('btn-invert');
  btn.disabled = true;
  btn.textContent = 'Inverting...';
  document.getElementById('invert-result').style.display = 'block';
  document.getElementById('original-text').textContent = currentText;
  document.getElementById('cosine-sim').textContent = '-';

  const grid = document.getElementById('token-grid');
  grid.innerHTML = '';

  let prevTokens = [];

  try {
    const r = await fetch('/decode', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({embedding: currentEmbedding, steps: 32, model: selectedModel})
    });

    const reader = r.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';
    let totalSteps = 32;
    let stepCount = 0;

    while (true) {
      const {done, value} = await reader.read();
      if (done) break;
      buffer += decoder.decode(value, {stream: true});

      const lines = buffer.split('\n');
      buffer = lines.pop();

      for (const line of lines) {
        if (!line.startsWith('data: ')) continue;
        const raw = line.slice(6).trim();
        if (raw === '[DONE]') continue;

        try {
          const d = JSON.parse(raw);
          stepCount++;

          if (d.total) totalSteps = d.total;
          if (d.total_steps) totalSteps = d.total_steps;
          const pct = d.progress ? d.progress * 100 : Math.min(100, (stepCount / totalSteps) * 100);
          document.getElementById('progress-fill').style.width = pct + '%';
          document.getElementById('step-info').textContent = `step ${d.step !== undefined ? d.step + 1 : stepCount}/${totalSteps}`;

          const tokens = d.tokens || [];
          grid.innerHTML = '';
          for (let i = 0; i < tokens.length; i++) {
            const span = document.createElement('span');
            // tokens can be objects {t: text, s: state} or strings
            const tok = typeof tokens[i] === 'object' ? tokens[i] : {t: tokens[i], s: 'u'};
            const text = tok.t || '';
            const isMask = text === '[MASK]' || text === '<mask>' || tok.s === 'm';
            const changed = tok.s === 'c' || (prevTokens[i] && prevTokens[i] !== text && !isMask);

            span.className = 'token ' + (isMask ? 'masked' : (changed ? 'just-changed' : 'revealed'));
            span.textContent = isMask ? '\u2588' : text;
            grid.appendChild(span);
          }
          prevTokens = tokens.map(t => typeof t === 'object' ? t.t : t);

          if (d.cosine_similarity !== undefined) {
            document.getElementById('cosine-sim').textContent = d.cosine_similarity.toFixed(4);
          } else if (d.cosine_sim !== undefined) {
            document.getElementById('cosine-sim').textContent = d.cosine_sim.toFixed(4);
          }
          if (d.text) {
            document.getElementById('recovered-text').textContent = d.text;
          }
        } catch(e) {}
      }
    }

    document.getElementById('progress-fill').style.width = '100%';
    document.getElementById('step-info').textContent = `done (${totalSteps} steps)`;
  } catch(e) {
    console.error(e);
  } finally {
    btn.disabled = false;
    btn.textContent = 'Invert';
  }
}

// Auto-load random on page load
window.addEventListener('load', randomSentence);
</script>
</body>
</html>
